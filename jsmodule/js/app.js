class MyApp {
    constructor() {
        this.questions = [
            {
                question: 'Eсть ли разница между window и document?',
                answer: `Да. У JavaScript есть глобальный объект и 
                        всё происходит через него. window – тот самый объект, 
                        который хранит глобальные переменные, функции, местоположение, историю. 
                        Всё находится внутри него, setTimeout, XMLHttpRequest, console и 
                        localStorage также являются частью window. Аналогично дело обстоит и 
                        с document, который является свойством объекта window и представляет DOM. 
                        Все ноды – это часть document, следовательно, вы можете использовать 
                        getElementById или addEventListener для document. Но обратите внимание, 
                        что этих методов нет в объекте window.`
            },
            {
                question: 'Вызываются ли document.onload и window.onload одновременно?',
                answer: `window.onload вызывается, когда DOM готов и весь контент, 
                        включая картинки, стили, фреймы и т.д. загружен. document.onload вызывается 
                        когда дерево DOM выстроено, но до момента, как подгружаются картинки, 
                        стили и пр.`
            },
            {
                question: 'Как предотвратить нажатие по ссылке?',
                answer: `Использовать preventDefault() внутри обработчика события.`
            },
            {
                question: 'Как остановить дальнейшее распространение события?',
                answer: `Вызвать event.stopPropagation();`
            },
            {
                question: 'Как я могу запустить обработчик в фазе захвата, а не в фазе всплытия?',
                answer: `В методах addEventListener и removeEventLister есть 
                        третий опциональный параметр. Вы можете установить его в true или 
                        false в зависимости от того хотите или нет использовать фазу захвата.`
            },
            {
                question: 'Каким образом можно предотвратить множественный вызов обработчика для одного события?',
                answer: ` Если слушатель события прикреплён к одному и тому же типу 
                        (click, keydown, и т.д.) элемента, вы можете вызвать event.stopImmediatePropagation() 
                        в первом обработчике и другие не будут выполнены.`
            },
            {
                question: 'Самовызывающиеся функции.',
                answer: `Тоже весьма частый вопрос на собеседованиях. 
                        Ещё иногда подходят к этому со стороны jQuery: 
                        «Почему все плагины обособлены в конструкцию (function() {})();?».`
            },
            {
                question: 'Как поменять контекст функции. Частичное применение функции. ',
                answer: `Тут нужно описать  разницу между 
                        .call, .apply и .bind и некоторых стандартных решений на уровне языка. `
            },
            {
                question: 'Разница между операторами == и === ',
                answer: `Оператор == сравнивает на равенство, а вот === — на идентичность. 
                        Плюс оператора === состоит в том, что он не приводит два значения 
                        к одному типу. Именно из-за этого он обычно и используется.`
            },
            {
                question: 'Каков будет результат выполнения следующего кода:',
                answer: `for (var i = 0; i < 10; i++) { 
                            setTimeout(function () { 
                            console.log(i); 
                            }, 0); 
                        }`
            },
            {
                question: 'Что вернет выражение +new Date()? Чем отличается от Date.now().',
                answer: `Отличный вопрос. Ответ в том, что +new Date(); 
                        создаст экземпляр объекта Date и благодаря + переведет 
                        его в числовой формат. Во втором случае вызовется 
                        статический метод конструктора, который является более 
                        приоритетным, т.к. во-первых он не требует создания 
                        экземпляра, а во-вторых является более понятным.`
            },
            {
                question: 'Напишите функцию принимающую строку с именем файла и возвращающую расширение (фрагмент после последней точки)',
                answer: `function getExtension(filename) {
                            var fragments = filename.split(".");
                            return fragments[fragments.length - 1];
                        }`
            },
            {
                question: 'В чём опасность использования for .. in для объекта или массива?',
                answer: `For..in итерируется по всем полям объекта [b]и его прототипов[/b] (т.е. проходит по всей цепочке прототипов).

                        В приведённом в вопросе коде проблем как таковых нет, но они могут появиться при использовании библиотек/полифиллов, которые переопределяют или создают новые свойства для прототипов стандартных конструкторов (таких как Array или Object).
                        
                        var arr = [3, 4, 5]; 
                        Array.prototype.each = function() {/*some fancy polyfill*/}; 
                        
                        for (var i in arr) { 
                            console.log(i); 
                        } 
                        Выведет
                        
                        0 
                        1 
                        2 
                        each 
                        Чтобы избежать таких проблем, можно воспользоваться методом
                        
                        Object.prototype.hasOwnProperty.
                        Модифицированный пример, который работает корректно:
                        
                        var arr = [3, 4, 5]; 
                        Array.prototype.each = function() {/*some fancy polyfill*/}; 
                        
                        for (var i in arr) { 
                            if (arr.hasOwnProperty(i)){ 
                                console.log(i); 
                            } 
                        }`
            },
            {
                question: `Какие языковые конструкции в javascript создают scope? Что произойдет при выполнении следующего куска кода?
                            var a = 90100; 
                            function someFunc(){ 
                            if(false){ 
                                var a = 1; 
                            } else { 
                                var b = 2; 
                            } 
                            console.log(b); 
                            console.log(a); //(1) 
                            } 
                            someFunc();`,
                answer: `javascript только функции создают новый scope.
                        console.log(i) //i здесь уже будет undefined                      
                        for(var i  = 0; i < 2; i++){ 
                        
                        } 
                        Код в вопросе аналогичен следующему:
                        
                        var a = 90100; 
                        function someFunc(){ 
                        var a; 
                        var b; 
                            if(false){ 
                            a = 1; 
                            } else { 
                            b = 2; 
                            } 
                            console.log(b); 
                            console.log(a); //(1) переменную a переопределили в функции 
                        } 
                        someFunc();
                        Результат выполнения:
                        
                        2 
                        undefined `
            },
            {
                question: `Что такое hoisting или "поднятие переменных"? Что произойдет при выполнении следующего куска кода?
                            myname = "global"; 
                            function func() { 
                                console.log(myname); 
                                var myname = "local"; 
                                console.log(myname); 
                            } 
                            func(); `,
                answer: `Интерпретатор JavaScript всегда перемещает («поднимает») объявления функций и переменных в начало области видимости (вверх текущего скрипта или функции). Код в вопросе аналогичен следующему:

                        myname = "global"; 
                        function func() { 
                            var myname; 
                            console.log(myname); // "undefined" 
                            myname = "local"; 
                            console.log(myname); // "local" 
                        } 
                        func(); 
                        В консоль будет напечатано:

                        undefined 
                        local `
            },
            {
                question: 'Как добавлять элементы на HTML страницу динамически ?',
                answer: `Создание новых элементов осуществляется с помощью document.createElement(tagName);

                        После создания элемента его нужно присоединить к родительскому элементу с помощью .appendChild(node);
                        
                        Пример:
                        
                        <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
                        <head> 
                        <title>Title</title> 
                        <script type="text/javascript"> 
                            function addNode() { 
                                var newP = document.createElement("p"); 
                                var textNode = document.createTextNode(" I'm a new text node"); 
                                newP.appendChild(textNode); 
                                document.getElementById("target").appendChild(newP); 
                            } 
                        </script> 
                        </head> 
                            <body onload="addNode();"> 
                                <p id="target">sart here<p> 
                            </body> 
                        </html> `
            },
            {
                question: 'В чем разница между Object.getOwnPropertyNames() и Object.keys()',
                answer: `Object.getOwnPropertyNames() возвращает перечислимые и не перечислимые свойства из объекта или массива.

                        var arr = ["a", "b", "c"]; 
                        print(Object.getOwnPropertyNames(arr).sort()); // prints "0,1,2,length" 
                        
                        // Array-like object 
                        var obj = { 0: "a", 1: "b", 2: "c"}; 
                        print(Object.getOwnPropertyNames(obj).sort()); // prints "0,1,2" 
                        Object.keys() возвращает перечислимые свойства из объекта или массива.
                        Пример:
                        
                        var arr = ["a", "b", "c"]; 
                        alert(Object.keys(arr)); // will alert "0,1,2" 
                        
                        // array like object 
                        var obj = { 0 : "a", 1 : "b", 2 : "c"}; 
                        alert(Object.keys(obj)); // will alert "0,1,2" `
            },
            {
                question: 'С помощью какой конструкции языка можно управлять потоком выполнения скрипта и отслеживать ошибки?',
                answer: `Это возможно с помощью конструкции try{}... catch{}

                        try { 
                            var number = 9; 
                            alert( number.toString(2) ); 
                            // ... 
                            alert('Выполнено без ошибок!'); 
                        } catch(e) { 
                            alert('Ошибка!'); 
                        } `
            },
            {
                question: `Почему вызов a(); происходит успешно, а вызов b(); выдает ошибку?
                            a(); //ok 
                            b(); //error 
                            
                            var b = function(){ 
                            alert( 'function b'); 
                            } 
                            
                            function a(){ 
                            alert( 'function a' ); 
                            } `,
                answer: `Функция а() инициализируется на этапе загрузки скрипта, как бы 
                        "всплывает вверх" а функция б инициализируется, когда объявляется переменная b`
            },
            {
                question: 'Что такое глобальные переменные ? Как они создаются ? Какие проблемы связаны с использованием глобальных переменных?',
                answer: `Глобальная переменная - переменная, которая доступна (видима) 
                        во всем документе, в отличии от локальной (ограничена рамками блока 
                        программного кода, внутри которого она определена) 

                        Пример:
                        
                        var myvar = 5; 
                        function myFunction(){ 
                        alert(myvar); // 5 
                        } 
                        Большинство JavaScript разработчиков избегает использования 
                        глобальных переменных. Одна из причин - возможный конфликт имен 
                        глобальных и локальных переменных. Так же код использующий 
                        глобальные переменные может быть тяжелее сопровождать и тестировать.`
            },
            {
                question: 'Что такое замыкания (closure) в JavaScript?',
                answer: `Простыми словами это внутренняя функция, т.е. функция в функции.
                        Замыканием (closure) называют потому, что после выполнения родительской или внешней функции, код внутренней все еще "живет" в интерпретаторе, и его можно выполнить. Ошибок не возникнет даже если внутренняя функция (замыкание) будет использовать переменные из внешней функции. 
                        Например, эту особенность можно использовать для создания функций обработчиков событий:
                        
                        (function addHandler() { 
                            var element = document.getElementById("element"); 
                            element.onclick = function() { 
                                alert("Привет из замыкания!"); 
                            }; 
                        })(); `
            },
            {
                question: 'расскажи ка про замыкания',
                answer: `Замыкание — это комбинация функции и лексического окружения, 
                        в котором эта функция была определена. Другими словами, замыкание 
                        дает вам доступ к Scope внешней функции из внутренней функции. 
                        В JavaScript замыкания создаются каждый раз при созданиии функции, 
                        во время ее создания.`
            },,
            {
                question: 'Что такое контекст выполнения',
                answer: `Контекст выполнения (execution context) — это, если говорить упрощённо, 
                        концепция, описывающая окружение, в котором производится выполнение кода на JavaScript. 
                        Код всегда выполняется внутри некоего контекста.
                        В JavaScript существует три типа контекстов выполнения:

                        Глобальный контекст выполнения. Это базовый, используемый по умолчанию контекст выполнения. 
                        Если некий код находится не внутри какой-нибудь функции, значит этот код принадлежит 
                        глобальному контексту. Глобальный контекст характеризуется наличием глобального объекта, 
                        которым, в случае с браузером, является объект window, и тем, что ключевое слово 
                        this указывает на этот глобальный объект. В программе может быть лишь один 
                        глобальный контекст.

                        Контекст выполнения функции. Каждый раз, когда вызывается функция, для неё создаётся 
                        новый контекст. Каждая функция имеет собственный контекст выполнения. В программе 
                        может одновременно присутствовать множество контекстов выполнения функций. 
                        При создании нового контекста выполнения функции он проходит через определённую 
                        последовательность шагов, о которой мы поговорим ниже.

                        Контекст выполнения функции eval. Код, выполняемый внутри функции eval, 
                        также имеет собственный контекст выполнения. Однако функцией eval пользуются 
                        очень редко, поэтому здесь мы об этом контексте выполнения говорить не будем.`
            },
            {
                question: 'Что такое Стек выполнения',
                answer: `Стек выполнения (execution stack), который ещё называют стеком 
                        вызовов (call stack), это LIFO-стек, который используется для хранения 
                        контекстов выполнения, создаваемых в ходе работы кода.

                        Когда JS-движок начинает обрабатывать скрипт, движок создаёт глобальный 
                        контекст выполнения и помещает его в текущий стек. При обнаружении 
                        команды вызова функции движок создаёт новый контекст выполнения для 
                        этой функции и помещает его в верхнюю часть стека.
                        
                        Движок выполняет функцию, контекст выполнения которой находится 
                        в верхней части стека. Когда работа функции завершается, её контекст 
                        извлекается из стека и управление передаётся тому контексту, который 
                        находится в предыдущем элементе стека.
                        
                        Изучим эту идею с помощью следующего примера:
                        let a = 'Hello World!';
                        function first() {
                        console.log('Inside first function');
                        second();
                        console.log('Again inside first function');
                        }
                        function second() {
                        console.log('Inside second function');
                        }
                        first();
                        console.log('Inside Global Execution Context');
                        
                        Привязка this
                        В глобальном контексте выполнения this содержит ссылку на глобальный 
                        объект (как уже было сказано, в браузере это объект window).

                        В контексте выполнения функции значение this зависит от того, 
                        как именно была вызвана функция. Если она вызвана в виде метода 
                        объекта, тогда значение this привязано к этому объекту. В других 
                        случаях this привязывается к глобальному объекту или устанавливается 
                        в undefined (в строгом режиме). Рассмотрим пример:
                        let foo = {
                            baz: function() {
                            console.log(this);
                            }
                          }
                          foo.baz();    // 'this' указывает на объект 'foo', так как функция 'baz' была вызвана 
                                       // как метод объекта 'foo'
                          let bar = foo.baz;
                          bar();       // 'this' указывает на глобальный объект window, так как при вызове функции
                                       // ссылка на объект не используется`
            },
            {
                question: 'Лексическое окружение',
                answer: `В соответствии со спецификацией ES6, лексическое окружение 
                        (Lexical Environment) — это термин, который используется для определения 
                        связи между идентификаторами и отдельными переменными и функциями на основе 
                        структуры лексической вложенности ECMAScript-кода. Лексическое окружение 
                        состоит из записи окружения (Environment Record) и ссылки на внешнее 
                        лексическое окружение, которая может принимать значение null.

                        Проще говоря, лексическое окружение — это структура, которая 
                        хранит сведения о соответствии идентификаторов и переменных. 
                        Под «идентификатором» здесь понимается имя переменной или функции, 
                        а под «переменной» — ссылка на конкретный объект 
                        (в том числе — на функцию) или примитивное значение.
                        
                        В лексическом окружении имеется два компонента:
                        
                        Запись окружения. Это место, где хранятся объявления переменных и функций.
                        Ссылка на внешнее окружение. Наличие такой ссылки говорит о том, 
                        что у лексического окружения есть доступ к родительскому 
                        лексическому окружению (области видимости).
                        
                        Существует два типа лексических окружений:
                        
                        Глобальное окружение (или глобальный контекст выполнения) — 
                        это лексическое окружение, у которого нет внешнего окружения. 
                        Ссылка глобального окружения на внешнее окружение представлена
                         значением null. В глобальном окружении (в записи окружения) 
                         доступны встроенные сущности языка (такие, как Object, Array, и так далее)
                         , которые связаны с глобальным объектом, там же находятся и глобальные 
                         переменные, определённые пользователем. Значение this в этом окружении 
                         указывает на глобальный объект.
                        Окружение функции, в котором, в записи окружения, хранятся переменные, 
                        объявленные пользователем. Ссылка на внешнее окружение может указывать 
                        как на глобальный объект, так и на внешнюю по отношении к рассматриваемой 
                        функции функцию.`
            },
            {
                question: 'Что такое Promise?',
                answer: `Promise – это специальный объект, который содержит своё состояние. 
                        Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») 
                        или rejected («выполнено с ошибкой»).
                        На promise можно навешивать колбэки двух типов:

                        onFulfilled – срабатывают, когда promise в состоянии «выполнен успешно».
                        onRejected – срабатывают, когда promise в состоянии «выполнен с ошибкой».
                        Способ использования, в общих чертах, такой:

                        Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.
                        Внешний код, получив promise, навешивает на него обработчики.
                        По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.
                        Синтаксис создания Promise:

                        var promise = new Promise(function(resolve, reject) {
                        // Эта функция будет вызвана автоматически

                        // В ней можно делать любые асинхронные операции,
                        // А когда они завершатся — нужно вызвать одно из:
                        // resolve(результат) при успешном выполнении
                        // reject(ошибка) при ошибке
                        })
                        Пример с setTimeout
                        Возьмём setTimeout в качестве асинхронной операции, которая должна через некоторое время успешно завершиться с результатом «result»:

                        'use strict';

                        // Создаётся объект promise
                        let promise = new Promise((resolve, reject) => {

                        setTimeout(() => {
                            // переведёт промис в состояние fulfilled с результатом "result"
                            resolve("result");
                        }, 1000);

                        });

                        // promise.then навешивает обработчики на успешный результат или ошибку
                        promise
                        .then(
                            result => {
                            // первая функция-обработчик - запустится при вызове resolve
                            alert("Fulfilled: " + result); // result - аргумент resolve
                            },
                            error => {
                            // вторая функция - запустится при вызове reject
                            alert("Rejected: " + error); // error - аргумент reject
                            }
                        );
                        В результате запуска кода выше – через 1 секунду выведется «Fulfilled: result».

                        А если бы вместо resolve("result") был вызов reject("error"), 
                        то вывелось бы «Rejected: error». Впрочем, как правило, если при 
                        выполнении возникла проблема, то reject вызывают не со строкой, 
                        а с объектом ошибки типа new Error:`
            },
            {
                question: '',
                answer: ``
            },
            
        ]
        this.questionPlace = document.getElementsByClassName('question')[0];
        this.answerPlace = document.getElementsByClassName('answer')[0];
        this.amountQuestions = document.querySelector('.amount');
        this.nextButton = document.querySelector('.next-button');
        this.showAnswerButton = document.querySelector('.show-answer-button');

        this.getRandomQuestion(this.questions);
        this.countAmountQuestions();
        this.index;

        this.showAnswerButton.onclick = () => this.onShowAnswerClick(this.index);
        this.nextButton.onclick = () => this.getRandomQuestion(this.questions);
    }

    getRandomQuestion(arr) {
        this.answerPlace.style.display = 'none'
        let randomIndex = Math.floor(Math.random()* arr.length);
        this.index = randomIndex;
        this.setRandomQuestion(this.questions[randomIndex]);
    }
    setRandomQuestion(element) {
        this.questionPlace.innerHTML = element.question;
        this.answerPlace.innerHTML = element.answer;
    }
    onShowAnswerClick(index) {
        this.answerPlace.innerHTML = this.questions[index].answer;
        this.answerPlace.style.display = 'flex'
    }
    countAmountQuestions() {
        this.amountQuestions.innerHTML = `questions are: ${this.questions.length}`
    }
}

const myapp = new MyApp();